use crate::ast::*;


#[derive(Default)]
pub struct Generator {
    
}

impl Generator {
    pub fn new() -> Self {
        Self { 
            
        }
    }

    pub fn generate(&mut self, ast: Vec<TLNode>) -> String {
        let mut class_name = "UnknownClassName".to_string(); // todo pass script name here
        let mut extends = "Object".to_string();

        let mut functions = String::new();

        for node in ast {
            match node {
                TLNode::ClassName(name) => class_name = name.clone(),
                TLNode::Extends(class) => extends = class.clone(),
                TLNode::Function { name, args, return_type, body } => {
                    let return_type = if return_type != Type::None {
                        "-> ".to_string() + &self.convert_type(return_type)
                    } else {
                        "".to_string()
                    };

                    let mut args_string = String::new();
                    for arg in args {
                        args_string += ", ";
                        args_string += &self.generate_variable(arg);
                    }

                    let mut body_string = String::new();
                    for node in body {
                        body_string += &self.generate_node(node);
                    }

                    let string = format!("#[func] fn {name}(&mut self {args_string}) {return_type} {{{body_string}}}");
                    functions.push_str(&string);
                }
            }
        }



        format!("

// Generated by GDScript-transpiler
use godot::prelude::*;

#[derive(GodotClass)]
#[class(init, base={extends})]
struct {class_name} {{
    // TODO vars
    base: Base<{extends}>
}}

#[godot_api]
impl {class_name} {{
    {functions}
}}


")
    }

    fn convert_type(&self, input: Type) -> String {
        match input {
            Type::None => todo!(),
            Type::Auto => String::new(),
            Type::Some(t) => match t.as_str() {
                "int" => "i64".to_string(),
                "float" => "f64".to_string(),
                _ => todo!()
            },
        }
    }

    fn generate_variable(&self, var: Variable) -> String {
        let name = var.name;
        let type_ = self.convert_type(var.type_);
        format!("{name}: {type_}")
    }

    fn generate_node(&self, node: Node) -> String {
        match node {
            Node::Return { body } => {
                let expr = if let Some(body) = body {
                    self.generate_expr(body)
                } else {
                    "".to_string()
                };

                format!("return {expr};")
            }
            Node::InitVar { var } => {
                let value = if let Some(e) = var.default_value {
                    self.generate_expr(e)
                } else {
                    "None".to_owned()
                };

                format!("let mut {} = {};", var.name, value)
            }
            Node::SetVar { name, op, value } => format!("{name} {op} {};", self.generate_expr(value)),
            

            Node::Expr(expr) => self.generate_expr(expr) + ";",
            Node::Break => { "break;".to_string() }
            Node::Continue => { "continue;".to_string() }
            _ => todo!()
        }
    }

    fn generate_expr(&self, expr: Expr) -> String {
        match expr {
            Expr::Number(n) => n.to_string(),
            Expr::FPNumber(n) => n.to_string(),
            Expr::Variable(var) => if var == "pass" { "".to_string() } else { var },

            Expr::Neg(expr) => "-".to_string() + &self.generate_expr(*expr),
            _ => todo!()
        }
    }
}
