use crate::ast::*;


#[derive(Default)]
pub struct Generator { }

impl Generator {
    pub fn new() -> Self {
        Self { }
    }

    pub fn generate(&mut self, ast: Vec<TLNode>) -> String {
        let mut class_name = "UnknownClassName".to_string(); // todo pass script name here
        let mut extends = "Object".to_string();

        let mut functions = String::new();

        for node in ast {
            match node {
                TLNode::ClassName(name) => class_name = name.clone(),
                TLNode::Extends(class) => extends = class.clone(),
                TLNode::Function { name, args, return_type, body } => {
                    let return_type = if return_type != Type::None {
                        "-> ".to_string() + &self.convert_type(return_type)
                    } else {
                        "".to_string()
                    };

                    let mut args_string = String::new();
                    for arg in args {
                        args_string += ", ";
                        args_string += &self.generate_variable(arg);
                    }

                    let mut body_string = String::new();
                    for node in body {
                        body_string += &self.generate_node(node);
                    }

                    let string = format!("#[func] fn {name}(&mut self {args_string}) {return_type} {{{body_string}}}");
                    functions.push_str(&string);
                }
            }
        }



        format!("

// Generated by GDScript-transpiler
use godot::prelude::*;

#[derive(GodotClass)]
#[class(init, base={extends})]
struct {class_name} {{
    // TODO vars
    base: Base<{extends}>
}}

#[godot_api]
impl {class_name} {{
    {functions}
}}


")
    }


    fn convert_type(&self, input: Type) -> String {
        match input {
            Type::None => "Option<Gd<Variant>>".to_owned(),
            Type::Auto => "_".into(),
            Type::Some(t) => match t.as_str() {
                "int" => "i64".to_string(),
                "float" => "f64".to_string(),
                _ => todo!()
            },
        }
    }

    fn generate_variable(&self, var: Variable) -> String {
        let name = var.name;
        let type_ = self.convert_type(var.type_);
        assert!(var.default_value.is_none(), "not supported yet");

        format!("{name}: {type_}")
    }

    fn generate_node(&self, node: Node) -> String {
        let mut node = match node {
            Node::Return { body } => {
                let expr = if let Some(body) = body {
                    self.generate_expr(body)
                } else {
                    "".to_string()
                };

                format!("return {expr}")
            }
            Node::InitVar { var } => {
                let type_ = self.convert_type(var.type_);
                let value = if let Some(e) = var.default_value {
                    self.generate_expr(e)
                } else {
                    "None".to_owned()
                };

                format!("let mut {}: {type_} = {}", var.name, value)
            }
            
            Node::SetVar { name, op, value } => format!("{name} {op} {}", self.generate_expr(value)),
            
            Node::If { condition, body, elif, or_else } => {

                let cond = self.generate_expr(condition);
                let mut body_string = String::new();
                for node in body {
                    body_string += &self.generate_node(node);
                }


                let mut else_if = String::new();
                for (cond, body) in elif {
                    let cond = self.generate_expr(cond);
                    let mut body_string = String::new();
                    for node in body {
                        body_string += &self.generate_node(node);
                    }

                    else_if += &format!("else if {cond} {{ {body_string} }}");
                }


                let mut else_ = String::new();
                if let Some(or_else) = or_else {
                    for node in or_else {
                        else_ += &self.generate_node(node);
                    }
                }

                format!("if {cond} {{ {body_string} }} {else_if} else {{ {else_} }}")
            }

            Node::Expr(expr) => self.generate_expr(expr),
            Node::Break => { "break".to_string() }
            Node::Continue => { "continue".to_string() }
            _ => todo!()
        };

        if !node.ends_with("}") {
            node += ";";
        }
        
        node
    }

    fn generate_expr(&self, expr: Expr) -> String {
        match expr {
            Expr::Number(n) => n.to_string(),
            Expr::FPNumber(n) => n.to_string(),
            Expr::Variable(var) => {
                match var.as_str() {
                    "pass" => "",
                    var => var
                }.to_owned()
            },

            Expr::Neg(expr) => "-".to_string() + &self.generate_expr(*expr),
            Expr::Op { lhs, op, rhs } => {
                //FIXME: This is wrong. Bracets need to be added
                format!("{} {op} {}", self.generate_expr(*lhs), self.generate_expr(*rhs))
            }

            _ => todo!()
        }
    }
}
